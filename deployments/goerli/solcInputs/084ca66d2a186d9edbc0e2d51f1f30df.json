{
  "language": "Solidity",
  "sources": {
    "contracts/Fundme.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n// import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n \n//  instead of copy pasting the whole interface as shown below we cn directly import it from gitHub and npm package\n// @chainlink/contracts refer to npm package\n\n// interface AggregatorV3Interface {\n//   function decimals() external view returns (uint8);\n\n//   function description() external view returns (string memory);\n\n//   function version() external view returns (uint256);\n\n//   function getRoundData(uint80 _roundId)\n//     external\n//     view\n//     returns (\n//       uint80 roundId,\n//       int256 answer,\n//       uint256 startedAt,\n//       uint256 updatedAt,\n//       uint80 answeredInRound\n//     );\n\n//   function latestRoundData()\n//     external\n//     view\n//     returns (\n//       uint80 roundId,\n//       int256 answer,\n//       uint256 startedAt,\n//       uint256 updatedAt,\n//       uint80 answeredInRound\n//     );\n// }\n\n\n// get fund ffronm user;\n// set a minium fund limit in usd\n// withdraw funds;\nimport 'contracts/PriceConverter.sol';\ncontract Fundme{\n    using PriceConverter for uint256;\n    // contract adressses can ghold fund asa wallet can\n    // to know hw much value  someone is sending we use msg.value;\n    \n    uint256 public miniumUSD=50*1e18;\n    address public owner;\n\n// constructor is a function that gets immediatly a called when a function is deployed\n// while ther function are created not called when we deploy ..we have to call them separately after deployment and if thery are not pure or view we transact them\n// here using constructor for initialisation we aare not required call the transaction many times;\n\n\n\n// refactorin gour codxefor mocking purposes\n// in the constructor we can actually pass thepricecfeedaddress as a parameter\n// as the pricefeed is now a parameterwe can change it as weswitch networks\n\nAggregatorV3Interface public  pricefeed;\nconstructor(address priceFeedAddress){\nowner=msg.sender;\npricefeed= AggregatorV3Interface(priceFeedAddress);\n}\n\n\n/* as we parameterize th epricefeed now we can pass it to functions similarly as \nasw are using a library priceconverter on uint ..we can pass price feed as aparameter as well to therese library fuction like to\ngetConversionRate()*/\n\n\n\n\n\n// array to keep atrack of all those sending ney to the smart contract\nmapping(address=>uint) public addressToMoney;\naddress[] public funders;\n\nfunction fund() public payable{\n     require(msg.value.getConvertCurrency(pricefeed) >= miniumUSD,\"Not sufficient funds send\");\n     funders.push(msg.sender);\n     addressToMoney[msg.sender]=msg.value;\n    \n    //  require staement reverts a transaction \n    // reverting means undo any action done before and send the remaing gas back\n    // gas will bespent but unsed gas will be reverted bsck to the account\n\n    // now we need to conver tour ether toreal world currency si=o that they are actually applicable to the real world\n}\n\n\n\n\n// MODIFIERS\n// require(msg.sender==owner,\"Only owner can withdraw\");\n// SUPPOSE we need this require condition checkin many function then we have to copy paste it many times\n// instead we usee modifiers;\n// so inside the modifier we set the functionality and add the modifier name at the end of function name;\n// _; implies first execute the require statement and then rest of the code inside the function on which it has been applied;\n// hence by applying mdifiers we change the functionalitiesof the function\n\nmodifier onlyOwner{\n    require(msg.sender==owner,\"Only owner can withdraw\");\n    _;\n}\n\n\n\nfunction withdraw()public onlyOwner{\nrequire(msg.sender==owner,\"Only owner can withdraw\");\n// updating the mapping of funder\naddress withDrawingFunder= msg.sender;\n\nfor(uint256 funderNum=0;funderNum < funders.length;funderNum++){\n\n    addressToMoney[withDrawingFunder]=0;\n}\n// resetting the funders array\n// in parenthesise we put the no of values with which wee want to initialise our array with\n// here it is 0 as we are initialising a blank array\nfunders= new address[](0);\n\n// 3 WAYS TO ACEESS BALANCE FROM A CONTRACT\n// transfer\n// call\n// send\n\n// retreiving balance from a contract using this;\n// payable(msg.sender).transfer(address(this).balance);\n// this refers to address of this entire contract\n// disadvantages==> transfer function is cappedd at 2300 gas and if more gas is used it throws an error;\n// if more gas  is used it throws an error; and revert the transaction\n\n\n// using send==> it is also capped at 2300 gas but will not throw an eror instead will return a bool\n  bool isSuccess=payable(msg.sender).send(address(this).balance);\n  require( isSuccess,\"Transaction not sent\");\n// hereas the transaction will not revert we will add the failure condition for send\n\n\n// usibg call\n// it is very powerful tool and is lower level function\n// we can use it to call any ethrium function on blockChain without even needing its abi;\n// here we atre using it for transcation and hem ce acan pass this.balance\n// ehen a function returns two parameters we can get it as shown\n//  it retrurns a bool and bytes data array to store the values returned by functions callled by it\n// bool is true if the function as successfully called\n// since we are not calling any function we use \"\"\n// (bool callSuccess, byts memory datareturned)= payable(msg.sender).call{value:address(this).balance}(\"\");\n(bool callSuccess,)= payable(msg.sender).call{value:address(this).balance}(\"\");\n  require( callSuccess,\"Transaction not sent\");\n\n\n\n\n\n\n}\n\n\n\n// INSTEAD OF AGAIN EXPLICITLY CREATING THESE FUNCTIONS WE WILL BE IMPORTING THE LIBRARY WE CRATED\n\n\n//  function getPrice()public view returns (uint){\n//      AggregatorV3Interface pricefeed= AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\n//      (,int price,,,)=pricefeed.latestRoundData();\n//     //  adjusting the decimal plaves with ether;\n//      return uint(price*1e10);\n\n\n// //    here will be importing the chainlink smart contract to get our usd price  but to do so we need\n// // ABI:is just info abouut the set of functions and methhods we can called to use etherium\n// // we can get abi by importing the whole contract but in that case we may unnecessaryly import lot of code \n// // hence we use interface knowing what function of te contract we can interct with\n\n\n// // address of the contact ==> obained from chainLInk io;0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\n\n//  }\n// // we dont use decimals in solidity so that we dont loose the precision\n\n// // fiunction to convert usd to ether{\n\n//     function getConvertCurrency(uint _usdAmount) public view returns(uint ){\n//         uint etherPrice=getPrice();\n//         uint convertedToEther= (_usdAmount*etherPrice)/1e18;\n//         return convertedToEther;\n\n\n\n//     }\n\n\n\n// function getVersion()public view returns (uint256){\n// // hence we can interact with the contract sthat exist outside our project using interfaces which gets compiled down to abi and we combine it with address to caall a function\n// AggregatorV3Interface pricefeed= AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\n// return pricefeed.version();\n// // it returns the version of the smart contract}\n\n// }\n}"
    },
    "contracts/PriceConverter.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// here we have to downlod hte npm of chain link oracle packad=ge in order to use it \r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nlibrary PriceConverter{\r\n\r\n// libraries can be used to a large extent to consolidate our code..\r\n// we will be exporting this library to our smart contract\r\n// we can apply library functions to any of our predefined data types or user defined data types\r\n// eg using PriceConverter for uint ====> we are applying the library functions to uint;\r\n// so now we can trat uint as an object and then use these function as methods of the function\r\n//  eg msg.sender.getConversionRate()\r\n\r\n\r\n\r\n\r\n\r\n\r\n   \r\n    \r\nfunction getPrice( AggregatorV3Interface pricefeed)internal view returns (uint){\r\n    // no longer \r\n    //  AggregatorV3Interface pricefeed= AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\r\n     (,int price,,,)=pricefeed.latestRoundData();\r\n    //  adjusting the decimal plaves with ether;\r\n     return uint(price*1e10);\r\n\r\n\r\n//    here will be importing the chainlink smart contract to get our usd price  but to do so we need\r\n// ABI:is just info abouut the set of functions and methhods we can called to use etherium\r\n// we can get abi by importing the whole contract but in that case we may unnecessaryly import lot of code \r\n// hence we use interface knowing what function of te contract we can interct with\r\n\r\n\r\n// address of the contact ==> obained from chainLInk io;0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\r\n\r\n }\r\n// we dont use decimals in solidity so that we dont loose the precision\r\n\r\n// fiunction to convert usd to ether{\r\n\r\n    function getConvertCurrency(uint _usdAmount, AggregatorV3Interface priceFeed) internal view returns(uint ){\r\n        uint etherPrice=getPrice(priceFeed);\r\n        uint convertedToEther= (_usdAmount*etherPrice)/1e18;\r\n        return convertedToEther;\r\n\r\n\r\n\r\n    }   \r\n\r\n\r\n\r\nfunction getVersion() internal view returns (uint256){\r\n// hence we can interact with the contract sthat exist outside our project using interfaces which gets compiled down to abi and we combine it with address to caall a function\r\nAggregatorV3Interface pricefeed= AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\r\nreturn pricefeed.version();\r\n// it returns the version of the smart contract}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}